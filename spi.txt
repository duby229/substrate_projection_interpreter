cargo.toml \\
[package]
name = "sptl-spi"
version = "0.1.0"
edition = "2021"
authors = ["Jon Duby <duby229@gmail.com>"]
description = "SPTL-SPI: Symbolic Pattern Theory Language - Symbolic Processing Interpreter"
license = "MIT OR GPL-3.0"

[dependencies]
rand = "0.8"

.gitignore \\
target/
*.rs.bk
*.log
.DS_Store
*.tmp

src/visualize.rs \\
pub fn print_vector(name: &str, vec: &[f64]) {
    let body = vec.iter().map(|v| format!("{:.2}", v)).collect::<Vec<_>>().join(", ");
    println!("{} = [{}]", name, body);
}

src/variables.rs \\
//! Symbolic variable support for SPTL shell.

use std::collections::HashMap;

#[derive(Clone)]
pub enum SymbolicValue {
    Symbol { token: String, pattern: String },
    Pattern(String),
    Token(String),
    // Extend as needed
}

#[derive(Default)]
pub struct VariableTable {
    table: HashMap<String, SymbolicValue>,
}

impl VariableTable {
    pub fn new() -> Self {
        Self { table: HashMap::new() }
    }

    pub fn set(&mut self, name: &str, value: SymbolicValue) {
        self.table.insert(name.to_string(), value);
    }

    pub fn get(&self, name: &str) -> Option<&SymbolicValue> {
        self.table.get(name)
    }
}

src/trace.rs \\
use crate::substrate::Substrate;
use crate::interpretation::Interpretation;

pub fn trace_distance(a: &Substrate, b: &Interpretation) -> f64 {
    a.state.iter()
        .zip(&b.data)
        .map(|(x, y)| (x - y).powi(2))
        .sum::<f64>()
        .sqrt()
}

pub fn coherence(a: &[f64], b: &[f64]) -> f64 {
    let dot = a.iter().zip(b).map(|(x, y)| x * y).sum::<f64>();
    let mag_a = a.iter().map(|x| x * x).sum::<f64>().sqrt();
    let mag_b = b.iter().map(|x| x * x).sum::<f64>().sqrt();
    if mag_a == 0.0 || mag_b == 0.0 {
        0.0
    } else {
        dot / (mag_a * mag_b)
    }
}

src/symbol.rs \\
//! Symbol/sign (‚Äª) and meaning module for SPTL.
//!
//! # Harmonized SPTL Principle
//!
//! - **Sign (‚Äª):** Not statically defined, but whatever an agent expresses and stabilizes through œÑ-indexed cycles. A sign is validated by participating in the say ‚Üí project ‚Üí interpret loop and persisting through tick.
//! - **Meaning:** Created by interpretation at a specific œÑ. Meaning is always situated in process and recursively re-enacted.
//!
//! See SPTL-Specification-Harmonization.md for more.

use crate::substrate::Pattern;

/// A symbolic sign: a token and a pattern.
/// Signs are not static; their identity emerges from cycles of expression, projection, and interpretation.
/// If it participates in the say ‚Üí project ‚Üí interpret loop and survives tick, it is a sign.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Symbol {
    /// The sign's token (e.g. word, name, identifier).
    pub token: String,
    /// The associated pattern.
    pub pattern: Pattern,
}

impl Symbol {
    /// Construct a new symbol (token, pattern pair).
    pub fn new(token: &str, pattern: Pattern) -> Self {
        Symbol {
            token: token.to_string(),
            pattern,
        }
    }

    /// Return a mutated version of the symbol (e.g. for drift/inheritance).
    pub fn mutate(&self) -> Symbol {
        let mutated = format!("{}*", self.token);
        Symbol::new(&mutated, self.pattern.clone())
    }
}

/// A meaning is an interpretation of a symbol at a recursion index (tau).
/// Meaning is always situated in œÑ; it only exists as an interpretive event.
#[derive(Debug, Clone)]
pub struct Meaning {
    /// The sign/symbol being interpreted.
    pub sign: Symbol,
    /// The recursion/time index at which this meaning was created.
    pub tau: usize,
    /// Human-readable description of the meaning.
    pub description: String,
}

impl Meaning {
    /// Create a new meaning from a symbol and recursion index.
    pub fn from_symbol(symbol: &Symbol, tau: usize) -> Self {
        Meaning {
            sign: symbol.clone(),
            tau,
            description: format!("Interpretation of '{}' at œÑ={}", symbol.token, tau),
        }
    }
}

src/substrate.rs \\
//! Substrate (‚óè) and pattern type for SPTL.
//!
//! # Harmonized SPTL Principle
//!
//! - **Substrate (‚óè):** A field of activations that are always decaying, always available for projection and resonance. If it can be activated and decayed, it is substrate.
//!

use std::collections::HashMap;
use crate::symbol::Symbol;

/// Represents a symbolic pattern (e.g., a bitstring, glyph, etc).
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Pattern(pub String);

impl Pattern {
    /// Construct a new pattern from a string.
    pub fn new(s: &str) -> Self {
        Pattern(s.to_string())
    }
}

/// The substrate (‚óè) is a field of activations for patterns.
/// It is always in flux: activations rise upon projection and decay over œÑ.
#[derive(Debug, Default)]
pub struct Substrate {
    /// Activation level for each pattern present in the substrate.
    pub activations: HashMap<Pattern, f64>,
}

impl Substrate {
    /// Project a symbol into the substrate, increasing its activation.
    pub fn project(&mut self, symbol: &Symbol) {
        let ent = self.activations.entry(symbol.pattern.clone()).or_insert(0.0);
        *ent += 1.0;
    }

    /// Decay all activations multiplicatively, removing those below threshold.
    pub fn decay(&mut self, rate: f64) {
        for v in self.activations.values_mut() {
            *v = (*v * (1.0 - rate)).max(0.0);
        }
        self.activations.retain(|_, v| *v > 0.01);
    }
}

src/slm.sptl \\
# SPTL Symbolic Language Model ‚Äî Evolution Script Example
# This script enacts the phased SLM evolution process in the SPTL interactive shell format.
# Each command matches shell syntax as described in src/shell.rs and the SLM evolution plan.

# -------- PHASE 1: Foundational Architecture --------

# Create primary agent with high memory, low coherence
agent create slm 128 0.25

# Seed basic lexicon
say slm origin 101010
say slm echo 110011
say slm drift 011110

# Project each sign into substrate and tick to enforce decay dynamics
project slm origin
project slm echo
project slm drift
tick
show agent slm
show substrate

# -------- PHASE 2: Recursion, Mutation & Feedback Loops --------

# Mutate high-stability symbols and express them
say slm origin* 101010
say slm echo* 110011
say slm drift* 011110

# Project mutated signs and interpret them
project slm origin*
project slm echo*
project slm drift*
interpret slm origin*
interpret slm echo*
interpret slm drift*
tick
show agent slm

# -------- PHASE 3: Meaning Formation & Interpretation Conditioning --------

# Further interpret all current signs, reinforcing memory and building interpretant history
interpret slm origin
interpret slm echo
interpret slm drift
interpret slm origin*
interpret slm echo*
interpret slm drift*
tick
show agent slm

# -------- PHASE 4: Emergent Grammar & Dialogic Training --------

# Create a second agent for symbolic dialogue
agent create echo 64 0.2
say echo listen 001100

# Project signs from slm agent and interpret with echo agent
project slm echo
interpret echo echo

# Start dialogic mutation/response between agents
say slm echo** 110011
project slm echo**
interpret echo echo**

say echo reply 011001
project echo reply
interpret slm reply
tick

show agent slm
show agent echo

# -------- PHASE 5: Metainterpretation & Reflective Abstraction --------

# Add meta-introspective and self-referential signs
say slm self 111111
say slm tau 000001
say slm remember 010101
say slm trace 100100

# Feed back interpretant as a new sign (example: summary or axiom)
interpret slm origin
say slm origin_trace 101010

say slm axiom1 "origin* and echo* persist longest"
say slm summary "Most persistent: origin, echo. Most mutated: drift*"
project slm summary
interpret slm summary

# Observe final agent state and substrate
show agent slm
show substrate

# END OF SCRIPT

src/shell.rs \\
mod narrative;

fn handle_run_script(&mut self, script: &str) {
    use narrative::{parser, runner};
    let blocks = parser::parse_script(script);
    let mut ctx = runner::ScriptContext::default();
    runner::execute_script(&blocks, &mut ctx);
}

src/projection.rs \\
use crate::substrate::Substrate;
use crate::interpretation::Interpretation;
use rand::Rng;

pub fn project(
    substrate: &mut Substrate,
    interpretation: &Interpretation,
    alpha: f64,
    noise: f64,
) {
    let mut rng = rand::thread_rng();
    for (s, i) in substrate.state.iter_mut().zip(&interpretation.data) {
        let n = rng.gen_range(-noise..=noise);
        *s = (1.0 - alpha) * *s + alpha * (*i + n);
    }
}

src/patterns.rs \\
//! Pattern abstraction support for SPTL shell.

use std::collections::HashMap;

/// Manages named patterns for symbolic reuse.
#[derive(Default)]
pub struct PatternTable {
    table: HashMap<String, String>,
}

impl PatternTable {
    pub fn new() -> Self {
        Self {
            table: HashMap::new(),
        }
    }

    /// Define or update a named pattern.
    pub fn define(&mut self, name: &str, value: &str) {
        self.table.insert(name.to_string(), value.to_string());
    }

    /// Expand pattern references in the input string.
    /// Replaces any [name] with its pattern definition.
    pub fn expand_patterns<'a>(&'a self, text: &'a str) -> String {
        let mut out = String::new();
        let mut chars = text.chars().peekable();
        while let Some(c) = chars.next() {
            if c == '[' {
                let mut name = String::new();
                while let Some(&n) = chars.peek() {
                    if n == ']' {
                        chars.next();
                        break;
                    }
                    name.push(n);
                    chars.next();
                }
                if let Some(val) = self.table.get(&name) {
                    out.push_str(val);
                } else {
                    out.push('[');
                    out.push_str(&name);
                    out.push(']');
                }
            } else {
                out.push(c);
            }
        }
        out
    }
}

src/main.rs \\
mod shell;
mod agents;
mod substrate;
mod symbol;

fn main() {
    let mut shell = shell::Shell::new();
    shell.run();
}

src/macros.rs //
! Macro support for SPTL shell.

use std::collections::HashMap;

pub struct Macro {
    pub params: Vec<String>,
    pub body: String,
}

#[derive(Default)]
pub struct MacroTable {
    table: HashMap<String, Macro>,
}

impl MacroTable {
    pub fn new() -> Self {
        Self { table: HashMap::new() }
    }

    pub fn define(&mut self, name: &str, params: Vec<String>, body: String) {
        self.table.insert(name.to_string(), Macro { params, body });
    }

    pub fn get(&self, name: &str) -> Option<&Macro> {
        self.table.get(name)
    }
}

src/interpretations.rs \\
#[derive(Clone)]
pub struct Interpretation {
    pub data: Vec<f64>,
}

impl Interpretation {
    pub fn new(data: Vec<f64>) -> Self {
        Interpretation { data }
    }
}

sr/config.rs \\
pub struct Config {
    pub alpha: f64,
    pub noise: f64,
    pub steps: usize,
}

src/agents.rs \\
//! Agents (‚üÅ), memory field (‚óê), and recursive interpretation (Œ†‚Çô) module.
//! 
//! # Harmonized SPTL Principle
//! 
//! - **Agent (‚üÅ):** Not merely a static data structure, but a *recursive semiotic attractor*‚Äîan entity whose identity and persistence are produced by its ongoing cycles of sign expression, projection, interpretation, and memory decay. If it recursively stabilizes and mutates signs, it is an agent.
//! - **Memory (‚óê):** Not a fixed store, but a dynamic field of traces always at risk of decay, always subject to reinforcement. Memory is whatever persists through feedback and interpretive cycles.
//! - **Interpretation (Œ†):** The act of making meaning, situated within the œÑ-indexed context; reinforces and potentially mutates the memory field.
//! 
//! See SPTL-Specification-Harmonization.md for more on behavioral ontology.

use std::collections::{HashMap, VecDeque};
use crate::substrate::{Substrate, Pattern};
use crate::symbol::{Symbol, Meaning};

/// Represents a memory trace for a symbol, with stability and interpretants.
/// A memory trace is not static: its stability emerges through feedback cycles.
#[derive(Debug, Clone)]
pub struct MemoryTrace {
    /// The symbol this trace refers to.
    pub symbol: Symbol,
    /// The recursion/time index when it was created.
    pub tau_index: usize,
    /// Stability [0,1] of the trace.
    pub stability: f64,
    /// All meanings/interpretations of the symbol for this trace.
    pub interpretants: Vec<Meaning>,
}

impl MemoryTrace {
    /// Reinforces the trace, increasing stability.
    pub fn reinforce(&mut self, delta: f64) {
        self.stability = (self.stability + delta).clamp(0.0, 1.0);
    }
    /// Decays the trace, decreasing stability.
    pub fn decay(&mut self, rate: f64) {
        self.stability = (self.stability - rate).max(0.0);
    }
}

/// MemoryField stores a queue of memory traces for an agent.
/// Memory is always dynamic, subject to decay and feedback.
#[derive(Debug, Default)]
pub struct MemoryField {
    /// The traces currently stored.
    pub traces: VecDeque<MemoryTrace>,
    /// Maximum number of traces to store.
    pub max_traces: usize,
}

impl MemoryField {
    /// Admit a new trace if stability ‚â• eta, evicting oldest if at capacity.
    pub fn admit(&mut self, trace: MemoryTrace, eta: f64) {
        if trace.stability >= eta {
            if self.traces.len() >= self.max_traces {
                self.traces.pop_front();
            }
            self.traces.push_back(trace);
        }
    }
    /// Reinforce stability for a matching symbol.
    pub fn reinforce_symbol(&mut self, symbol: &Symbol, delta: f64) {
        for t in &mut self.traces {
            if &t.symbol == symbol {
                t.reinforce(delta);
            }
        }
    }
    /// Decay all traces, removing those below threshold.
    pub fn decay_all(&mut self, rate: f64) {
        for t in &mut self.traces {
            t.decay(rate);
        }
        self.traces.retain(|t| t.stability > 0.0);
    }
    /// Find a trace by symbol.
    pub fn find(&self, symbol: &Symbol) -> Option<&MemoryTrace> {
        self.traces.iter().find(|t| &t.symbol == symbol)
    }
}

/// Symbolic agent (‚üÅ): owns memory, a sign table, and core parameters.
/// Agents are recursive processes: their identity is enacted through cycles of sign expression, projection, and interpretation.
/// See SPTL-Specification-Harmonization.md for principle: "If it recursively stabilizes and mutates signs, it is an agent."
#[derive(Debug)]
pub struct Agent {
    /// Agent identifier.
    pub id: String,
    /// All known symbols (token ‚Üí pattern).
    pub symbol_table: HashMap<String, Pattern>,
    /// Agent's memory field.
    pub memory: MemoryField,
    /// Minimum stability required for memory admission.
    pub coherence_threshold: f64,
}

impl Agent {
    /// Construct a new agent with given memory and coherence.
    pub fn new(id: impl Into<String>, max_memory: usize, coherence_threshold: f64) -> Self {
        Agent {
            id: id.into(),
            symbol_table: HashMap::new(),
            memory: MemoryField {
                traces: VecDeque::with_capacity(max_memory),
                max_traces: max_memory,
            },
            coherence_threshold,
        }
    }

    /// Express a symbol (token, pattern), adding a trace if stable.
    /// In SPTL, expression is an act that can recursively reinforce or mutate the system.
    pub fn express_symbol(&mut self, token: &str, pattern: Pattern, tau: usize) -> Symbol {
        let symbol = Symbol::new(token, pattern.clone());
        self.symbol_table.insert(token.to_string(), pattern);
        let trace = MemoryTrace {
            symbol: symbol.clone(),
            tau_index: tau,
            stability: 1.0,
            interpretants: Vec::new(),
        };
        self.memory.admit(trace, self.coherence_threshold);
        symbol
    }

    /// Project a symbol into the substrate.
    pub fn project_symbol(&self, symbol: &Symbol, substrate: &mut Substrate) {
        substrate.project(symbol);
    }

    /// Attempt to interpret a symbol, reinforcing memory if successful.
    pub fn interpret_symbol(&mut self, symbol: &Symbol, tau: usize) -> Option<Meaning> {
        if let Some(pattern) = self.symbol_table.get(&symbol.token) {
            if pattern == &symbol.pattern {
                self.memory.reinforce_symbol(symbol, 0.1);
                let meaning = Meaning::from_symbol(symbol, tau);
                if let Some(trace) = self.memory.traces.iter_mut().find(|t| &t.symbol == symbol) {
                    trace.interpretants.push(meaning.clone());
                }
                return Some(meaning);
            }
        }
        None
    }

    /// Return a mutated version of the symbol.
    pub fn mutate_symbol(&self, symbol: &Symbol) -> Symbol {
        symbol.mutate()
    }

    /// Decay all memory traces.
    pub fn decay_memory(&mut self, rate: f64) {
        self.memory.decay_all(rate);
    }
}

src/sptl/mod.rs \\
use std::collections::HashMap;
use crate::substrate::Substrate;
use crate::interpretation::Interpretation;
use crate::projection::project;
use crate::trace::{trace_distance, coherence};
use crate::visualize::print_vector;

#[derive(Debug)]
pub enum Statement {
    Field { name: String, size: usize },
    Interpretation { name: String, values: Vec<f64> },
    Project {
        target: String,
        interp: String,
        alpha: f64,
        noise: f64,
        steps: usize,
    },
    TraceDistance { name: String, field: String, interp: String },
    Meaning { name: String, trace_cmp: String, threshold: f64 },
    NarrateReturn { tokens: Vec<String> },
    LogCoherence(String),
    LogMeaning(String),
    ExpressSymbol { token: String, into_field: String },
    Modulate { token: String, intensity: f64 },
}

pub struct Tokenizer<'a> {
    input: &'a str,
}

impl<'a> Tokenizer<'a> {
    pub fn new(input: &'a str) -> Self {
        Tokenizer { input }
    }

    pub fn tokenize(&mut self) -> Vec<String> {
        self.input
            .split_whitespace()
            .map(|s| s.trim_matches(&['"', ',', '[', ']'][..]).to_string())
            .collect()
    }
}pub struct Parser {
    tokens: Vec<String>,
    cursor: usize,
}

impl Parser {
    pub fn new(tokens: Vec<String>) -> Self {
        Parser { tokens, cursor: 0 }
    }

    pub fn parse(&mut self) -> Vec<Statement> {
        let mut statements = Vec::new();
        while self.cursor < self.tokens.len() {
            if let Some(stmt) = self.parse_statement() {
                statements.push(stmt);
            } else {
                break;
            }
        }
        statements
    }

    fn parse_statement(&mut self) -> Option<Statement> {
        let t = self.next()?.to_lowercase();
        match t.as_str() {
            "field" => {
                let name = self.next()?;
                let size = self.next()?.parse().ok()?;
                Some(Statement::Field { name, size })
            }
            "interpretation" => {
                let name = self.next()?;
                self.expect("=")?;
                self.expect("[")?;
                let mut values = Vec::new();
                while let Some(tok) = self.peek() {
                    if tok == "]" {
                        self.next();
                        break;
                    }
                    if let Ok(num) = tok.parse::<f64>() {
                        values.push(num);
                        self.next();
                    } else {
                        break;
                    }
                }
                Some(Statement::Interpretation { name, values })
            }
            "project" => {
                let target = self.next()?;
                self.expect("<-")?;
                let interp = self.next()?;
                self.expect("{")?;
                let alpha = self.expect_value("alpha:")?;
                let noise = self.expect_value("noise:")?;
                let steps = self.expect_value("steps:")? as usize;
                self.expect("}")?;
                Some(Statement::Project {
                    target,
                    interp,
                    alpha,
                    noise,
                    steps,
                })
            }
            "trace" => {
                let name = self.next()?;
                self.expect("=")?;
                let func = self.next()?;
                self.expect("(")?;
                let field = self.next()?;
                self.expect(",")?;
                let interp = self.next()?;
                self.expect(")")?;
                Some(Statement::TraceDistance {
                    name,
                    field,
                    interp,
                })
            }
            "meaning" => {
                let name = self.next()?;
                self.expect("=")?;
                let func = self.next()?;
                self.expect("(")?;
                let trace_cmp = self.next()?;
                self.expect(",")?;
                let threshold = self.next()?.parse().ok()?;
                self.expect(")")?;
                Some(Statement::Meaning {
                    name,
                    trace_cmp,
                    threshold,
                })
            }
            "narratereturn" => {
                let mut tokens = Vec::new();
                while let Some(tok) = self.peek() {
                    if tok.starts_with('"') {
                        tokens.push(tok.trim_matches('"').to_string());
                        self.next();
                    } else {
                        break;
                    }
                }
                Some(Statement::NarrateReturn { tokens })
            }
            "logcoherence" => {
                let field = self.next()?;
                Some(Statement::LogCoherence(field))
            }
            "logmeaning" => {
                let name = self.next()?;
                Some(Statement::LogMeaning(name))
            }
            "expresssymbol" => {
                let token = self.next()?;
                let _ = self.next()?; // into_field
                let field = self.next()?;
                Some(Statement::ExpressSymbol {
                    token,
                    into_field: field,
                })
            }
            "modulate" => {
                let token = self.next()?;
                let _ = self.next()?; // intensity
                let val = self.next()?.parse().ok()?;
                Some(Statement::Modulate { token, intensity: val })
            }
            _ => None,
        }
    }

    fn next(&mut self) -> Option<String> {
        if self.cursor < self.tokens.len() {
            let t = self.tokens[self.cursor].clone();
            self.cursor += 1;
            Some(t)
        } else {
            None
        }
    }

    fn peek(&self) -> Option<&str> {
        self.tokens.get(self.cursor).map(|s| s.as_str())
    }

    fn expect(&mut self, expected: &str) -> Option<()> {
        let token = self.next()?;
        if token.to_lowercase() == expected.to_lowercase() {
            Some(())
        } else {
            None
        }
    }

    fn expect_value(&mut self, label: &str) -> Option<f64> {
        let l = self.next()?;
        if !l.starts_with(label) {
            return None;
        }
        let val = self.next()?.parse().ok()?;
        Some(val)
    }
}
pub fn execute_program(program: Vec<Statement>) {
    let mut fields: HashMap<String, Substrate> = HashMap::new();
    let mut interps: HashMap<String, Interpretation> = HashMap::new();

    for stmt in program {
        match stmt {
            Statement::Field { name, size } => {
                fields.insert(name, Substrate::new(size));
            }
            Statement::Interpretation { name, values } => {
                interps.insert(name, Interpretation::new(values));
            }
            Statement::Project {
                target,
                interp,
                alpha,
                noise,
                steps,
            } => {
                if let (Some(field), Some(interp_val)) =
                    (fields.get_mut(&target), interps.get(&interp))
                {
                    for _ in 0..steps {
                        project(field, interp_val, alpha, noise);
                    }
                } else {
                    eprintln!("‚ö†Ô∏è Unknown field or interpretation in Project");
                }
            }
            Statement::TraceDistance {
                name,
                field,
                interp,
            } => {
                if let (Some(f), Some(i)) = (fields.get(&field), interps.get(&interp)) {
                    let result = trace_distance(f, i);
                    println!("Trace {} = {:.4}", name, result);
                } else {
                    eprintln!("‚ö†Ô∏è Unknown field or interpretation in TraceDistance");
                }
            }
            Statement::Meaning {
                name,
                trace_cmp,
                threshold,
            } => {
                println!("üí° Meaning {} ‚Üê {} < {}", name, trace_cmp, threshold);
            }
            Statement::NarrateReturn { tokens } => {
                println!("üó£ {}", tokens.join(" "));
            }
            Statement::LogCoherence(name) => {
                if let Some(f) = fields.get(&name) {
                    print_vector(&format!("Œ®[{}]", name), &f.state);
                } else {
                    eprintln!("‚ö†Ô∏è Unknown field in LogCoherence");
                }
            }
            Statement::LogMeaning(name) => {
                println!("üß† Meaning declared: {}", name);
            }
            Statement::ExpressSymbol {
                token,
                into_field,
            } => {
                println!("‚ûï Expressed {} into {}", token, into_field);
            }
            Statement::Modulate { token, intensity } => {
                println!("üéõ Modulated {} @ {:.2}", token, intensity);
            }
        }
    }
}

src/narrative/runner.rs \\
//! Runner for SPTL narrative DSL with macros

use super::ast::{Block, Action};
use std::collections::HashMap;

#[derive(Default)]
pub struct ScriptContext {
    pub vars: HashMap<String, String>,
    pub macros: HashMap<String, (Vec<String>, Vec<Action>)>,
    pub agents: HashMap<String, AgentState>,
    pub tau: u64,
}

#[derive(Default, Debug, Clone)]
pub struct AgentState {
    pub memory: Vec<String>,
    pub activation: HashMap<String, f32>,
}

pub fn execute_script(blocks: &[Block], ctx: &mut ScriptContext) {
    // First pass: register macros
    for block in blocks {
        if let Block::MacroDef { name, params, body } = block {
            ctx.macros.insert(name.clone(), (params.clone(), body.clone()));
        }
    }
    // Second pass: execute non-macro blocks
    for block in blocks {
        match block {
            Block::MacroDef { .. } => {},
            _ => execute_block(block, ctx),
        }
    }
}

fn execute_block(block: &Block, ctx: &mut ScriptContext) {
    match block {
        Block::AtTau(tau, actions) => {
            ctx.tau = *tau;
            println!("--- at œÑ={} ---", tau);
            for action in actions {
                execute_action(action, ctx);
            }
        }
        Block::Repeat(n, actions) => {
            for i in 0..*n {
                println!("Repeat iteration {}/{}", i + 1, n);
                for action in actions {
                    execute_action(action, ctx);
                }
            }
        }
        Block::While(cond, actions) => {
            let mut count = 0;
            while eval_condition(cond, ctx) {
                println!("While iteration {}", count + 1);
                for action in actions {
                    execute_action(action, ctx);
                }
                count += 1;
                if count > 1000 {
                    println!("Breaking infinite while loop: more than 1000 iterations.");
                    break;
                }
            }
        }
        Block::Parallel(actions) => {
            println!("-- Parallel block --");
            for action in actions {
                execute_action(action, ctx);
            }
        }
        Block::MacroDef { .. } => {}
    }
}

fn execute_action(action: &Action, ctx: &mut ScriptContext) {
    match action {
        Action::Conditional(cond, subactions) => {
            if eval_condition(cond, ctx) {
                println!("Condition '{}' passed.", cond);
                for sub in subactions {
                    execute_action(sub, ctx);
                }
            } else {
                println!("Condition '{}' failed.", cond);
            }
        }
        Action::CreateAgent { name, mem, coh } => {
            println!("Create agent {} mem={} coh={}", name, mem, coh);
            ctx.agents.insert(name.clone(), AgentState::default());
        }
        Action::VariableAssignment { name, value } => {
            let val = expand_vars(value, ctx);
            println!("Set variable {} = {}", name, val);
            ctx.vars.insert(name.clone(), val);
        }
        Action::Say { agent, token, pattern } => {
            let token = expand_vars(token, ctx);
            let pattern = expand_vars(pattern, ctx);
            println!("{} says: {} ‚Üí {}", agent, token, pattern);
            ctx.agents.entry(agent.clone()).or_default().memory.push(token.clone());
        }
        Action::Interpret { agent, token } => {
            let token = expand_vars(token, ctx);
            println!("{} interprets: {}", agent, token);
            ctx.agents.entry(agent.clone()).or_default().memory.push(token.clone());
        }
        Action::Project { agent, token } => {
            let token = expand_vars(token, ctx);
            println!("{} projects: {}", agent, token);
        }
        Action::Tick(n) => {
            println!("Advance œÑ by {}", n);
            ctx.tau += *n as u64;
        }
        Action::Assert(expr) => {
            println!("Assert: {}", expr);
        }
        Action::Comment(text) => {
            println!("# {}", text);
        }
        Action::MacroCall { name, args } => {
            if let Some((params, body)) = ctx.macros.get(name) {
                if params.len() != args.len() {
                    println!("Macro {} expects {} arguments, got {}", name, params.len(), args.len());
                    return;
                }
                let old_vars = ctx.vars.clone();
                for (p, a) in params.iter().zip(args.iter()) {
                    ctx.vars.insert(p.clone(), expand_vars(a, ctx));
                }
                for act in body {
                    execute_action(act, ctx);
                }
                ctx.vars = old_vars;
            } else {
                println!("Macro '{}' not found.", name);
            }
        }
    }
}

fn eval_condition(cond: &str, ctx: &ScriptContext) -> bool {
    if cond == "always" {
        return true;
    }
    let tokens: Vec<&str> = cond.split_whitespace().collect();
    if tokens.len() == 3 && tokens[1] == "knows" {
        if let Some(agent) = ctx.agents.get(tokens[0]) {
            return agent.memory.contains(&tokens[2].to_string());
        }
    }
    if tokens.len() == 3 && tokens[1] == "memory" && tokens[2].starts_with("contains") {
        let agent = tokens[0];
        let item = cond.split("contains").nth(1).unwrap().trim();
        if let Some(agent) = ctx.agents.get(agent) {
            return agent.memory.contains(&item.to_string());
        }
    }
    println!("Condition '{}' not recognized, default false.", cond);
    false
}

fn expand_vars(text: &str, ctx: &ScriptContext) -> String {
    let mut result = String::new();
    let mut chars = text.chars().peekable();
    while let Some(c) = chars.next() {
        if c == '$' {
            let mut name = String::new();
            while let Some(&n) = chars.peek() {
                if !n.is_alphanumeric() && n != '_' { break; }
                name.push(n);
                chars.next();
            }
            if let Some(val) = ctx.vars.get(&name) {
                result.push_str(val);
            } else {
                result.push('$');
                result.push_str(&name);
            }
        } else {
            result.push(c);
        }
    }
    result
}

src/narrative/parser.rs \\
//! Parser for SPTL narrative DSL with macro support

use super::ast::{Block, Action};
use std::collections::VecDeque;

struct LineCursor<'a> {
    lines: VecDeque<(usize, &'a str)>,
}
impl<'a> LineCursor<'a> {
    fn from(script: &'a str) -> Self {
        let mut lines = VecDeque::new();
        for line in script.lines() {
            let trimmed = line.trim_start();
            if trimmed.is_empty() || trimmed.starts_with('#') {
                continue;
            }
            let indent = line.len() - trimmed.len();
            lines.push_back((indent, trimmed));
        }
        Self { lines }
    }
    fn peek(&self) -> Option<&(usize, &'a str)> {
        self.lines.front()
    }
    fn next(&mut self) -> Option<(usize, &'a str)> {
        self.lines.pop_front()
    }
}

pub fn parse_script(script: &str) -> Vec<Block> {
    let mut cursor = LineCursor::from(script);
    let mut blocks = Vec::new();
    while let Some((_, line)) = cursor.peek() {
        if line.starts_with("macro ") {
            blocks.push(parse_macro_def(&mut cursor));
        } else if line.starts_with("at œÑ=") {
            blocks.push(parse_at_tau(&mut cursor));
        } else if line.starts_with("repeat ") {
            blocks.push(parse_repeat(&mut cursor));
        } else if line.starts_with("while ") {
            blocks.push(parse_while(&mut cursor));
        } else if line.starts_with("parallel:") {
            blocks.push(parse_parallel(&mut cursor));
        } else {
            blocks.push(parse_at_tau(&mut cursor));
        }
    }
    blocks
}

fn parse_macro_def(cursor: &mut LineCursor) -> Block {
    let (base_indent, header) = cursor.next().unwrap();
    let header = header.trim_start_matches("macro").trim();
    let open_paren = header.find('(').unwrap();
    let close_paren = header.find(')').unwrap();
    let name = header[..open_paren].trim().to_string();
    let params: Vec<String> = header[open_paren + 1..close_paren]
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    let mut body = Vec::new();
    while let Some((indent, _)) = cursor.peek() {
        if *indent <= base_indent {
            break;
        }
        body.append(&mut parse_action_block(cursor, base_indent + 2));
    }
    Block::MacroDef { name, params, body }
}

fn parse_at_tau(cursor: &mut LineCursor) -> Block {
    let (base_indent, header) = cursor.next().unwrap();
    let tau: u64 = header.trim_start_matches("at œÑ=").split(':').next().unwrap().trim().parse().unwrap();
    let mut actions = Vec::new();
    while let Some((indent, _)) = cursor.peek() {
        if *indent <= base_indent {
            break;
        }
        actions.append(&mut parse_action_block(cursor, base_indent + 2));
    }
    Block::AtTau(tau, actions)
}

fn parse_repeat(cursor: &mut LineCursor) -> Block {
    let (base_indent, header) = cursor.next().unwrap();
    let n: u32 = header.trim_start_matches("repeat")
        .split("times").next().unwrap().trim().parse().unwrap();
    let mut actions = Vec::new();
    while let Some((indent, _)) = cursor.peek() {
        if *indent <= base_indent {
            break;
        }
        actions.append(&mut parse_action_block(cursor, base_indent + 2));
    }
    Block::Repeat(n, actions)
}

fn parse_while(cursor: &mut LineCursor) -> Block {
    let (base_indent, header) = cursor.next().unwrap();
    let cond = header.trim_start_matches("while").trim_end_matches(':').trim().to_string();
    let mut actions = Vec::new();
    while let Some((indent, _)) = cursor.peek() {
        if *indent <= base_indent {
            break;
        }
        actions.append(&mut parse_action_block(cursor, base_indent + 2));
    }
    Block::While(cond, actions)
}

fn parse_parallel(cursor: &mut LineCursor) -> Block {
    let (base_indent, _) = cursor.next().unwrap();
    let mut actions = Vec::new();
    while let Some((indent, _)) = cursor.peek() {
        if *indent <= base_indent {
            break;
        }
        actions.append(&mut parse_action_block(cursor, base_indent + 2));
    }
    Block::Parallel(actions)
}

fn parse_action_block(cursor: &mut LineCursor, min_indent: usize) -> Vec<Action> {
    let (indent, line) = cursor.next().unwrap();
    if line.starts_with("if ") && line.ends_with(':') {
        let cond = line.trim_start_matches("if").trim_end_matches(':').trim().to_string();
        let mut subactions = Vec::new();
        while let Some((next_indent, _)) = cursor.peek() {
            if *next_indent <= indent {
                break;
            }
            subactions.append(&mut parse_action_block(cursor, indent + 2));
        }
        vec![Action::Conditional(cond, subactions)]
    } else {
        vec![parse_action(line)]
    }
}

fn parse_action(line: &str) -> Action {
    if let Some(rest) = line.strip_prefix("create agent ") {
        let mut parts = rest.split_whitespace();
        let name = parts.next().unwrap().to_string();
        let mem: u32 = parts.next().unwrap().parse().unwrap();
        let coh: f32 = parts.next().unwrap().parse().unwrap();
        Action::CreateAgent { name, mem, coh }
    } else if let Some(rest) = line.strip_prefix("let ") {
        let (name, value) = rest.split_once('=').unwrap();
        Action::VariableAssignment {
            name: name.trim().to_string(),
            value: value.trim().to_string(),
        }
    } else if let Some(rest) = line.strip_prefix("tick ") {
        let n = rest.trim().parse().unwrap();
        Action::Tick(n)
    } else if let Some(rest) = line.strip_prefix("assert ") {
        Action::Assert(rest.trim().to_string())
    } else if let Some((agent, rest)) = line.split_once(" says: ") {
        let (token, pattern) = rest.split_once(" ‚Üí ").unwrap();
        Action::Say {
            agent: agent.trim().to_string(),
            token: token.trim().to_string(),
            pattern: pattern.trim().to_string(),
        }
    } else if let Some((agent, rest)) = line.split_once(" hears: ") {
        let (token, _) = rest.split_once(" ‚Üí ").unwrap();
        Action::Interpret {
            agent: agent.trim().to_string(),
            token: token.trim().to_string(),
        }
    } else if let Some((agent, rest)) = line.split_once(" interprets: ") {
        Action::Interpret {
            agent: agent.trim().to_string(),
            token: rest.trim().to_string(),
        }
    } else if line.contains('(') && line.ends_with(')') {
        let open_paren = line.find('(').unwrap();
        let close_paren = line.find(')').unwrap();
        let name = line[..open_paren].trim().to_string();
        let argstr = &line[open_paren + 1..close_paren];
        let args: Vec<String> = argstr.split(',').map(|s| s.trim().to_string()).collect();
        Action::MacroCall { name, args }
    } else if line.starts_with('#') {
        Action::Comment(line[1..].trim().to_string())
    } else {
        panic!("Unrecognized action: {}", line);
    }
}

src/narrative/mod.rs \\
pub mod ast;
pub mod parser;
pub mod runner;

src/narrative/ast.rs \\
//! AST for SPTL narrative DSL with macro support

#[derive(Debug, Clone)]
pub enum Block {
    AtTau(u64, Vec<Action>),
    Repeat(u32, Vec<Action>),
    While(String, Vec<Action>),
    Parallel(Vec<Action>),
    MacroDef { name: String, params: Vec<String>, body: Vec<Action> },
}

#[derive(Debug, Clone)]
pub enum Action {
    Conditional(String, Vec<Action>),
    CreateAgent { name: String, mem: u32, coh: f32 },
    MacroCall { name: String, args: Vec<String> },
    VariableAssignment { name: String, value: String },
    Say { agent: String, token: String, pattern: String },
    Interpret { agent: String, token: String },
    Project { agent: String, token: String },
    Tick(u32),
    Assert(String),
    Comment(String),
}